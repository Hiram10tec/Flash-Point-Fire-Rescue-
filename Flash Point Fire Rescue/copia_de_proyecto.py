# -*- coding: utf-8 -*-
"""Copia de Proyecto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/186co5lPCxAvawv3dFSHy95BPd6TIyZlc
"""

!pip install mesa

# Commented out IPython magic to ensure Python compatibility.
from mesa import Agent, Model

# Debido a que necesitamos que existe un solo agente por celda, elegimos
# ''SingleGrid''.
from mesa.space import MultiGrid

# Con ''SimultaneousActivation, hacemos que todos los agentes se activen
# ''al mismo tiempo''.
from mesa.time import RandomActivation

# Haremos uso de ''DataCollector'' para obtener información de cada paso
# de la simulación.
from mesa.datacollection import DataCollector

import random

# matplotlib lo usaremos crear una animación de cada uno de los pasos
# del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores
# numéricos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de
# ejecución de nuestro algoritmo.
import time
import datetime

def getGrid(model):
    """
    Devuelve una copia de la cuadrícula con las posiciones de paredes, fuego y agentes actualizados.

    Parámetros:
    model (object): El modelo que contiene las matrices y lista de agentes.

    Retorno:
    numpy.array: Una copia de la cuadrícula con los valores actualizados de paredes, fuego y agentes.
    """
    grid = np.copy(model.matriz_pared)

    # Actualiza la cuadrícula con el estado del fuego
    for i in range(0, model.grid.width, 2):
        for j in range(0, model.grid.height, 2):
            if model.matriz_fuego[i][j] == 1:
                grid[i][j] = 9
            elif model.matriz_fuego[i][j] == 2:
                grid[i][j] = 10

    # Actualiza la cuadrícula con la posición de los agentes
    for agent in model.schedule.agents:
        if agent.pos is not None:
            grid[agent.pos[0]][agent.pos[1]] = 11

    return grid

class Nodo:
    """
    Representa un nodo en una lista enlazada circular.

    Parámetros:
    data (any): El valor almacenado en el nodo.
    """
    def __init__(self, data):
        self.data = data
        self.next = None

class Fila:
    """
    Representa una lista enlazada circular con operaciones push y pop.

    Atributos:
    head (Nodo): El nodo al inicio de la lista.
    tail (Nodo): El nodo al final de la lista.
    pointer (Nodo): Puntero al nodo actual.
    size (int): El tamaño de la lista.
    """
    def __init__(self):
        self.head = None
        self.tail = None
        self.pointer = None
        self.size = 0

    def push(self, data):
        """
        Inserta un nuevo nodo en la lista circular.

        Parámetros:
        data (any): El valor a insertar en el nodo.
        """
        nodo = Nodo(data)
        if self.size == 0:
            self.head = nodo
            self.pointer = self.head
        else:
            self.tail.next = nodo
        nodo.next = self.head
        self.tail = nodo
        self.size += 1

    def pop(self, data):
        """
        Elimina un nodo que contenga el valor especificado.

        Parámetros:
        data (any): El valor a eliminar de la lista.
        """
        if self.size == 0:
            return

        p = self.head
        q = self.head.next

        if p.data == data:
            self.head = q
            self.tail.next = self.head
        else:
            while q.data != data:
                p = p.next
                q = q.next
            p.next = q.next
            if q == self.tail:
                self.tail = p

        self.size -= 1

class Building(Model):
    def __init__(self, largo, ancho, num_agents, paredes, puertas, entradas, fuegos, POIs):
        """
        Inicializa el modelo del edificio.

        Args:
        - largo (int): Número de filas del edificio.
        - ancho (int): Número de columnas del edificio.
        - num_agents (int): Número de agentes (bomberos).
        - paredes (list): Lista de paredes que contiene información sobre la presencia de paredes en las celdas.
        - puertas (list): Lista de puertas que conectan las celdas del edificio.
        - entradas (list): Lista de entradas disponibles en el edificio.
        - fuegos (list): Lista de celdas que contienen fuego.
        - POIs (list): Lista de puntos de interés en el edificio (víctimas o falsas alarmas).
        """
        super().__init__()
        self.grid = MultiGrid(largo*2 + 3, ancho*2 + 3, torus = False)
        self.schedule = RandomActivation(self)

        # Configura el recolector de datos del modelo.
        self.datacollector = DataCollector(
            model_reporters = {
                "Grid": get_grid
            }
        )

        # Configura las propiedades del modelo.
        self.largo = largo
        self.ancho = ancho
        self.running = True
        self.matriz_pared = np.zeros((largo*2 + 3, ancho*2 + 3))
        self.entradas = np.array(entradas)*2
        self.matriz_fuego = np.zeros((largo*2 + 3, ancho*2 + 3))
        self.agentes_vivos = Fila()
        self.POIs = []
        self.game_POI = POIs
        self.victims = []

        self.take_action = True
        self.go_fire = False
        self.spread_fire = False
        self.go_POI = False

        # Configura la matriz de paredes iniciales.
        for i in range(1, largo*2 + 2, 2):
            for j in range(ancho*2 + 3):
                self.matriz_pared[i][j] = 1

        for i in range(largo*2 + 3):
            for j in range(1, ancho*2 + 2, 2):
                self.matriz_pared[i][j] = 1
        # Ajusta las paredes según la entrada del parámetro 'paredes'.
        for i in range(largo):
            for j in range(ancho):
                if paredes[i][j][0] == 1:
                    self.matriz_pared[i*2 + 1][j*2 + 2] = 3
                if paredes[i][j][1] == 1:
                    self.matriz_pared[i*2 + 2][j*2 + 1] = 3
                if paredes[i][j][2] == 1:
                    self.matriz_pared[i*2 + 3][j*2 + 2] = 3
                if paredes[i][j][3] == 1:
                    self.matriz_pared[i*2 + 2][j*2 + 3] = 3

                 # Ajusta las intersecciones de las paredes.
                if paredes[i][j][0] == 1 and paredes[i][j][1] == 1:
                    self.matriz_pared[i*2 + 1][j*2 + 1] = 3
                if paredes[i][j][0] == 1 and paredes[i][j][3] == 1:
                    self.matriz_pared[i*2 + 1][j*2 + 3] = 3
                if paredes[i][j][2] == 1 and paredes[i][j][1] == 1:
                    self.matriz_pared[i*2 + 3][j*2 + 1] = 3
                if paredes[i][j][2] == 1 and paredes[i][j][3] == 1:
                    self.matriz_pared[i*2 + 3][j*2 + 3] = 3

        # Ajusta las paredes internas en celdas con dos paredes opuestas.
        for i in range(1, largo*2 + 2, 2):
            for j in range(1, ancho*2 + 2, 2):
                if i > 0 and i < largo*2:
                    if self.matriz_pared[i-1][j] == 3 and self.matriz_pared[i+1][j] == 3:
                        self.matriz_pared[i][j] = 3
                if j > 0 and j < ancho*2:
                    if self.matriz_pared[i][j-1] == 3 and self.matriz_pared[i][j+1] == 3:
                        self.matriz_pared[i][j] = 3

        for i in range(len(puertas)):
            if puertas[i][0] == puertas[i][2]:
                self.matriz_pared[puertas[i][0]*2][puertas[i][1]*2 + 1] = 4
            if puertas[i][1] == puertas[i][3]:
                self.matriz_pared[puertas[i][0]*2 + 1][puertas[i][1]*2] = 4

        # Añade puertas a la matriz de paredes.
        for i in range(len(self.entradas)):
            if self.entradas[i][0] == 2:
                self.matriz_pared[1][self.entradas[i][1]] = 6
            if self.entradas[i][0] == self.grid.width - 3:
                self.matriz_pared[self.grid.width - 2][self.entradas[i][1]] = 6
            if self.entradas[i][1] == 2:
                self.matriz_pared[self.entradas[i][0]][1] = 6
            if self.entradas[i][1] == self.grid.height - 3:
                self.matriz_pared[self.entradas[i][0]][self.grid.height - 2] = 6

        # Ajusta las entradas del edificio.
        for i in range(len(fuegos)):
            self.matriz_fuego[fuegos[i][0]*2][fuegos[i][1]*2] = 2

         # Coloca el fuego en la matriz de fuego.
        for i in range(len(self.game_POI)):
            self.matriz_pared[POIs[i][0]*2][POIs[i][1]*2] = 7

        # Añade los puntos de interés (POIs).
        while self.count_true(self.POIs) < 8 \
        and len(self.POIs) - self.count_true(self.POIs) < 4:
            self.POIs.append(self.random.choice([True, False, True]))

        while self.count_true(self.POIs) < 8:
            self.POIs.append(True)

        while len(self.POIs) - self.count_true(self.POIs) < 4:
            self.POIs.append(False)


        for i in range(num_agents):
            a = Bombero(i, self)
            x, y = self.random.choice(self.entradas)
            self.grid.place_agent(a, (x,y))
            self.schedule.add(a)
            self.agentes_vivos.push(a)

    def count_true(self, array):
        """
        Cuenta la cantidad de elementos True en un array.

        Parámetros:
        array (list): El array a contar.

        Retorno:
        int: La cantidad de elementos True en el array.
        """
        count = 0
        for i in range(len(array)):
            if array[i]:
                count += 1
        return count

    def step(self):
        """
        Ejecuta un paso de la simulación.
        """
        self.schedule.step()
        self.datacollector.collect(self)
        if self.agentes_vivos.size == 0:
            self.running = False
            return
        if self.agentes_vivos.size > 0:
            agente = self.agentes_vivos.pointer.data

        if self.take_action:
            agente.step()
            if agente.action_points == 0 or agente.end_turn:
                agente.action_points = min(agente.action_points + 4, 8)
                self.agentes_vivos.pointer = self.agentes_vivos.pointer.next
                self.go_fire = True
                self.take_action = False
        elif self.go_fire:
            self.advance_fire()
            self.go_fire = False
            self.spread_fire = True
        elif self.spread_fire:
            self.super_fire()
            self.spread_fire = False
            self.take_action = True


    def advance_fire(self):
        """
        Avanza el fuego en la simulación.
        """
        dados = (random.randint(1, self.largo), random.randint(1, self.ancho))
        self.matriz_fuego[dados[0]*2][dados[1]*2] += 1

        if self.matriz_fuego[dados[0]*2][dados[1]*2] == 3:
            self.matriz_fuego[dados[0]*2][dados[1]*2] = 2

            if self.matriz_pared[dados[0]*2 - 1][dados[1]*2] == 3 \
            or self.matriz_pared[dados[0]*2 - 1][dados[1]*2] == 2:
                self.matriz_pared[dados[0]*2 - 1][dados[1]*2] -= 1
            elif self.matriz_pared[dados[0]*2 - 1][dados[1]*2] == 4:
                self.matriz_pared[dados[0]*2 - 1][dados[1]*2] = 1
            elif self.matriz_pared[dados[0]*2 - 1][dados[1]*2] == 5 \
            and self.matriz_fuego[dados[0]*2 - 2][dados[1]*2] != 2:
                self.matriz_pared[dados[0]*2 - 1][dados[1]*2] = 1
                self.matriz_fuego[dados[0]*2 - 2][dados[1]*2] = 2
            elif self.matriz_fuego[dados[0]*2 - 2][dados[1]*2] != 2:
                self.matriz_fuego[dados[0]*2 - 2][dados[1]*2] = 2
            elif self.matriz_fuego[dados[0]*2 - 2][dados[1]*2] == 2:
                pos1 = dados[0]*2 - 2
                pos2 = dados[1]*2
                while self.matriz_fuego[pos1][pos2] == 2 \
                and pos1 > 0 \
                and self.matriz_pared[pos1 + 1][pos2] != 3 \
                and self.matriz_pared[pos1 + 1][pos2] != 2 \
                and self.matriz_pared[pos1 + 1][pos2] != 4:
                    pos1 -= 2
                if self.matriz_pared[pos1 + 1][pos2] == 3 \
                or self.matriz_pared[pos1 + 1][pos2] == 2:
                    self.matriz_pared[pos1 + 1][pos2] -= 1
                elif self.matriz_pared[pos1 + 1][pos2] == 4:
                    self.matriz_pared[pos1 + 1][pos2] = 1
                elif self.matriz_pared[pos1 + 1][pos2] == 5:
                    self.matriz_pared[pos1 + 1][pos2] = 1
                    self.matriz_fuego[pos1][pos2] = 2
                else:
                    self.matriz_fuego[pos1][pos2] = 2

            if self.matriz_pared[dados[0]*2 + 1][dados[1]*2] == 3 \
            or self.matriz_pared[dados[0]*2 + 1][dados[1]*2] == 2:
                self.matriz_pared[dados[0]*2 + 1][dados[1]*2] -= 1
            elif self.matriz_pared[dados[0]*2 + 1][dados[1]*2] == 4:
                self.matriz_pared[dados[0]*2 + 1][dados[1]*2] = 1
            elif self.matriz_pared[dados[0]*2 + 1][dados[1]*2] == 5 \
            and self.matriz_fuego[dados[0]*2 + 2][dados[1]*2] != 2:
                self.matriz_pared[dados[0]*2 + 1][dados[1]*2] = 1
                self.matriz_fuego[dados[0]*2 + 2][dados[1]*2] = 2
            elif self.matriz_fuego[dados[0]*2 + 2][dados[1]*2] != 2:
                self.matriz_fuego[dados[0]*2 + 2][dados[1]*2] = 2
            elif self.matriz_fuego[dados[0]*2 + 2][dados[1]*2] == 2:
                pos1 = dados[0]*2 + 2
                pos2 = dados[1]*2
                while self.matriz_fuego[pos1][pos2] == 2 \
                and pos1 < self.grid.width - 1 \
                and self.matriz_pared[pos1 - 1][pos2] != 3 \
                and self.matriz_pared[pos1 - 1][pos2] != 2 \
                and self.matriz_pared[pos1 - 1][pos2] != 4:
                    pos1 += 2
                if self.matriz_pared[pos1 - 1][pos2] == 3 \
                or self.matriz_pared[pos1 - 1][pos2] == 2:
                    self.matriz_pared[pos1 - 1][pos2] -= 1
                elif self.matriz_pared[pos1 - 1][pos2] == 4:
                    self.matriz_pared[pos1 - 1][pos2] = 1
                elif self.matriz_pared[pos1 - 1][pos2] == 5:
                    self.matriz_pared[pos1 - 1][pos2] = 1
                    self.matriz_fuego[pos1][pos2] = 2
                else:
                    self.matriz_fuego[pos1][pos2] = 2

            if self.matriz_pared[dados[0]*2][dados[1]*2 - 1] == 3 \
            or self.matriz_pared[dados[0]*2][dados[1]*2 - 1] == 2:
                self.matriz_pared[dados[0]*2][dados[1]*2 - 1] -= 1
            elif self.matriz_pared[dados[0]*2][dados[1]*2 - 1] == 4:
                self.matriz_pared[dados[0]*2][dados[1]*2 - 1] = 1
            elif self.matriz_pared[dados[0]*2][dados[1]*2 - 1] == 5 \
            and self.matriz_fuego[dados[0]*2][dados[1]*2 - 2] != 2:
                self.matriz_pared[dados[0]*2][dados[1]*2 - 1] = 1
                self.matriz_fuego[dados[0]*2][dados[1]*2 - 2] = 2
            elif self.matriz_fuego[dados[0]*2][dados[1]*2 - 2] != 2:
                self.matriz_fuego[dados[0]*2][dados[1]*2 - 2] = 2
            elif self.matriz_fuego[dados[0]*2][dados[1]*2 - 2] == 2:
                pos1 = dados[0]*2
                pos2 = dados[1]*2 - 2
                while self.matriz_fuego[pos1][pos2] == 2 \
                and pos2 > 0 \
                and self.matriz_pared[pos1][pos2 + 1] != 3 \
                and self.matriz_pared[pos1][pos2 + 1] != 2 \
                and self.matriz_pared[pos1][pos2 + 1] != 4:
                    pos2 -= 2
                if self.matriz_pared[pos1][pos2 + 1] == 3 \
                or self.matriz_pared[pos1][pos2 + 1] == 2:
                    self.matriz_pared[pos1][pos2 + 1] -= 1
                elif self.matriz_pared[pos1][pos2 + 1] == 4:
                    self.matriz_pared[pos1][pos2 + 1] = 1
                elif self.matriz_pared[pos1][pos2 + 1] == 5:
                    self.matriz_pared[pos1][pos2 + 1] = 1
                    self.matriz_fuego[pos1][pos2] = 2
                else:
                    self.matriz_fuego[pos1][pos2] = 2

            if self.matriz_pared[dados[0]*2][dados[1]*2 + 1] == 3 \
            or self.matriz_pared[dados[0]*2][dados[1]*2 + 1] == 2:
                self.matriz_pared[dados[0]*2][dados[1]*2 + 1] -= 1
            elif self.matriz_pared[dados[0]*2][dados[1]*2 + 1] == 4:
                self.matriz_pared[dados[0]*2][dados[1]*2 + 1] = 1
            elif self.matriz_pared[dados[0]*2][dados[1]*2 + 1] == 5 \
            and self.matriz_fuego[dados[0]*2][dados[1]*2 + 2] != 2:
                self.matriz_pared[dados[0]*2][dados[1]*2 + 1] = 1
                self.matriz_fuego[dados[0]*2][dados[1]*2 + 2] = 2
            elif self.matriz_fuego[dados[0]*2][dados[1]*2 + 2] != 2:
                self.matriz_fuego[dados[0]*2][dados[1]*2 + 2] = 2
            elif self.matriz_fuego[dados[0]*2][dados[1]*2 + 2] == 2:
                pos1 = dados[0]*2
                pos2 = dados[1]*2 + 2
                while self.matriz_fuego[pos1][pos2] == 2 \
                and pos2 < self.grid.height - 1 \
                and self.matriz_pared[pos1][pos2 - 1] != 3 \
                and self.matriz_pared[pos1][pos2 - 1] != 2 \
                and self.matriz_pared[pos1][pos2 - 1] != 4:
                    pos2 += 2
                if self.matriz_pared[pos1][pos2 - 1] == 3 \
                or self.matriz_pared[pos1][pos2 - 1] == 2:
                    self.matriz_pared[pos1][pos2 - 1] -= 1
                elif self.matriz_pared[pos1][pos2 - 1] == 4:
                    self.matriz_pared[pos1][pos2 - 1] = 1
                elif self.matriz_pared[pos1][pos2 - 1] == 5:
                    self.matriz_pared[pos1][pos2 - 1] = 1
                    self.matriz_fuego[pos1][pos2] = 2
                else:
                    self.matriz_fuego[pos1][pos2] = 2

    def super_fire(self):
        """
        Expande el fuego en la simulación.
        """
        for i in range(0, self.grid.width, 2):
            for j in range(0, self.grid.height, 2):
                if self.matriz_fuego[i][j] == 1:
                    if self.matriz_pared[i - 1][j] != 3 \
                    and self.matriz_pared[i - 1][j] != 2 \
                    and self.matriz_pared[i - 1][j] != 4 \
                    and self.matriz_fuego[i - 2][j] == 2:
                        self.matriz_fuego[i][j] = 2
                        self.super_fire()
                    elif self.matriz_pared[i + 1][j] != 3 \
                    and self.matriz_pared[i + 1][j] != 2 \
                    and self.matriz_pared[i + 1][j] != 4 \
                    and self.matriz_fuego[i + 2][j] == 2:
                        self.matriz_fuego[i][j] = 2
                        self.super_fire()
                    elif self.matriz_pared[i][j - 1] != 3 \
                    and self.matriz_pared[i][j - 1] != 2 \
                    and self.matriz_pared[i][j - 1] != 4 \
                    and self.matriz_fuego[i][j - 2] == 2:
                        self.matriz_fuego[i][j] = 2
                        self.super_fire()
                    elif self.matriz_pared[i][j + 1] != 3 \
                    and self.matriz_pared[i][j + 1] != 2 \
                    and self.matriz_pared[i][j + 1] != 4 \
                    and self.matriz_fuego[i][j + 2] == 2:
                        self.matriz_fuego[i][j] = 2
                        self.super_fire()

    def kill(self):
        """
        Elimina los agentes muertos de la simulación.
        """
        for i in range(0, self.grid.width, 2):
            for j in range(0, self.grid.height, 2):
                if self.matriz_fuego[i][j] == 2:
                    cell = self.grid.get_cell_list_contents((i,j))
                    for agent in cell:
                        self.agentes_vivos.pop(agent)
                        self.grid.remove_agent(agent)
                    if self.matriz_pared[i][j] == 7:
                        for k in range(len(self.game_POI)):
                            if self.game_POI[k][0] == i and self.game_POI[k][1] == j:
                                self.game_POI.pop(k)
                    if self.matriz_pared[i][j] == 8:
                        for k in range(len(self.victims)):
                            if self.victims[k][0] == i and self.victims[k][1] == j:
                                self.victims.pop(k)

    def replenish_POIs(self):
        """
        Repone los puntos de interés (POIs) en la simulación.
        """
        while len(self.game_POI) + len(self.victims) < 3:
            dado1 = random.randint(1, self.largo)
            dado2 = random.randint(1, self.ancho)
            while self.matriz_pared[dado1*2][dado2*2] == 7:
                dado1 = random.randint(1, self.largo)
                dado2 = random.randint(1, self.ancho)
            self.matriz_pared[dado1*2][dado2*2] = 7
            self.matriz_fuego[dado1*2][dado2*2] = 0
            self.game_POI.append([dado1, dado2, self.POIs[0]])
            self.POIs.pop(0)

class Bombero(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        """
        Inicializa el agente Bombero.

        Parámetros:
        - unique_id: Identificador único del agente.
        - model: Instancia del modelo de simulación.

        Atributos:
        - carrying_victim (bool): Indica si el bombero está cargando una víctima.
        - action_points (int): Puntos de acción disponibles para el bombero, inicializados en 4.
        - afuera (bool): Indica si el bombero está fuera del edificio (en una zona de salida).
        - end_turn (bool): Indica si el turno del bombero ha finalizado.
        """
        self.carrying_victim = False
        self.action_points = 4
        self.afuera = False
        self.end_turn = False

    def step(self):
        """
        Define el comportamiento del bombero en cada paso de la simulación.
        El bombero evalúa las posibles acciones, como moverse, apagar fuego, abrir puertas,
        destruir paredes, o revelar un Punto de Interés (POI). Las acciones son elegidas
        en función de los puntos de acción disponibles y el estado del entorno.
        """

        # Si el bombero no tiene una posición, no hace nada
        if self.pos is None:
            return

        # Vecindario alrededor de la posición del bombero
        possible_steps = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)
        door_steps = [step for step in possible_steps
                      if self.model.matriz_pared[step[0]][step[1]] == 4
                      or self.model.matriz_pared[step[0]][step[1]] == 5]
        possible_door = [step for step in door_steps
                         if self.action_points > 0]
        # Filtrar pasos posibles que tienen puertas
        wall_steps = [step for step in possible_steps
                      if self.model.matriz_pared[step[0]][step[1]] == 3
                      or self.model.matriz_pared[step[0]][step[1]] == 2]
        possible_wall = [step for step in wall_steps
                         if self.action_points > 1]
        # Detectar fuego en las posiciones cercanas
        fire_steps = []
        if self.pos[0] > 1:
            if self.model.matriz_fuego[self.pos[0] - 2][self.pos[1]] > 0 \
            and self.model.matriz_pared[self.pos[0] - 1][self.pos[1]] != 3 \
            and self.model.matriz_pared[self.pos[0] - 1][self.pos[1]] != 2 \
            and self.model.matriz_pared[self.pos[0] - 1][self.pos[1]] != 4:
                fire_steps.append((self.pos[0] - 2, self.pos[1]))
        if self.pos[0] < self.model.grid.width - 2:
            if self.model.matriz_fuego[self.pos[0] + 2][self.pos[1]] > 0 \
            and self.model.matriz_pared[self.pos[0] + 1][self.pos[1]] != 3 \
            and self.model.matriz_pared[self.pos[0] + 1][self.pos[1]] != 2 \
            and self.model.matriz_pared[self.pos[0] + 1][self.pos[1]] != 4:
                fire_steps.append((self.pos[0] + 2, self.pos[1]))
        if self.pos[1] > 1:
            if self.model.matriz_fuego[self.pos[0]][self.pos[1] - 2] > 0 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] - 1] != 3 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] - 1] != 2 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] - 1] != 4:
                fire_steps.append((self.pos[0], self.pos[1] - 2))
        if self.pos[1] < self.model.grid.height - 2:
            if self.model.matriz_fuego[self.pos[0]][self.pos[1] + 2] > 0 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] + 1] != 3 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] + 1] != 2 \
            and self.model.matriz_pared[self.pos[0]][self.pos[1] + 1] != 4:
                fire_steps.append((self.pos[0], self.pos[1] + 2))
        if self.model.matriz_fuego[self.pos[0]][self.pos[1]] > 0:
            fire_steps.append(self.pos)

        # Filtrar posiciones con fuego que pueden ser apagadas
        possible_fire = [step for step in fire_steps
                         if self.action_points > 0]

        # Si el bombero está en una casilla con un POI, lo revela
        if self.model.matriz_pared[self.pos[0]][self.pos[1]] == 7:
            self.reveal_POI()
        # Si hay fuego cercano, lo apaga
        elif possible_fire:
            choice = self.random.choice(possible_fire)
            self.apag_fire(choice)

        # Si hay una puerta o una pared disponible, decide si abrir la puerta o destruir la pared
        elif possible_door and possible_wall:
            choice = self.random.choice([i for i in range(9)])
            if choice < 6 and self.action_points > 1:
                self.random_move()
            elif 5 < choice < 8:
                self.flip_door(self.random.choice(door_steps))
            else:
                self.chop_wall(self.random.choice(wall_steps))
        # Si hay una puerta cercana, puede intentar abrirla o moverse
        elif possible_door:
            choice = self.random.choice([0,1,2])
            if choice < 2 and self.action_points > 0:
                self.random_move()
            else:
                self.flip_door(self.random.choice(door_steps))

        # Si hay una pared cercana, puede destruirla o moverse
        elif possible_wall:
            choice = self.random.choice([i for i in range(7)])
            if choice < 6 and self.action_points > 0:
                self.random_move()
            else:
                self.chop_wall(self.random.choice(wall_steps))
        # Si no hay otras acciones disponibles, se mueve aleatoriamente
        elif self.action_points > 0:
            self.random_move()


    def random_move(self):
        """
        Realiza un movimiento aleatorio a una casilla válida cercana.
        Evita paredes y fuego, y si está fuera del edificio, intenta regresar.
        Reduce 1 punto de acción.
        """
        possible_steps = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)
        valid_steps = [step for step in possible_steps
                       if self.model.matriz_pared[step[0]][step[1]] != 2
                       and self.model.matriz_pared[step[0]][step[1]] != 3
                       and self.model.matriz_pared[step[0]][step[1]] != 4]

        # Ajustar los pasos válidos si hay desplazamiento por 2 celdas
        for i in range(len(valid_steps)):
            if valid_steps[i] == (self.pos[0] - 1, self.pos[1]):
                valid_steps[i] = (self.pos[0] - 2, self.pos[1])
            if valid_steps[i] == (self.pos[0] + 1, self.pos[1]):
                valid_steps[i] = (self.pos[0] + 2, self.pos[1])
            if valid_steps[i] == (self.pos[0], self.pos[1] - 1):
                valid_steps[i] = (self.pos[0], self.pos[1] - 2)
            if valid_steps[i] == (self.pos[0], self.pos[1] + 1):
                valid_steps[i] = (self.pos[0], self.pos[1] + 2)

        safe_steps = [step for step in valid_steps
                      if self.model.matriz_fuego[step[0]][step[1]] != 2]
        # Verifica si el bombero está fuera del edificio y trata de reingresar
        if safe_steps:
            new_pos = self.random.choice(safe_steps)

            if self.afuera:
                if self.pos[0] == 0:
                    reg_pos = (self.pos[0] + 2, self.pos[1])
                    if reg_pos in safe_steps:
                        self.model.grid.move_agent(self, reg_pos)
                        self.afuera = False
                    else:
                        self.model.grid.move_agent(self, new_pos)

                elif self.pos[0] == self.model.grid.width - 1:
                    reg_pos = (self.pos[0] - 2, self.pos[1])
                    if reg_pos in safe_steps:
                        self.model.grid.move_agent(self, reg_pos)
                        self.afuera = False
                    else:
                        self.model.grid.move_agent(self, new_pos)

                elif self.pos[1] == 0:
                    reg_pos = (self.pos[0], self.pos[1] + 2)
                    if reg_pos in safe_steps:
                        self.model.grid.move_agent(self, reg_pos)
                        self.afuera = False
                    else:
                        self.model.grid.move_agent(self, new_pos)

                elif self.pos[1] == self.model.grid.height - 1:
                    reg_pos = (self.pos[0], self.pos[1] - 2)
                    if reg_pos in safe_steps:
                        self.model.grid.move_agent(self, reg_pos)
                        self.afuera = False
                    else:
                        self.model.grid.move_agent(self, new_pos)

            else:
                self.model.grid.move_agent(self, new_pos)
            # Verifica si está en una salida
            if self.pos[0] == 0 or self.pos[0] == self.model.grid.width - 1 \
            or self.pos[1] == 0 or self.pos[1] == self.model.grid.height - 1:
                self.afuera = True
            #Reduce los puntos de acción
            self.action_points -= 1

        else:
            self.end_turn = True


    def flip_door(self, pos):
        """
        Abre o cierra una puerta en una posición específica.
        Si la puerta está cerrada (5), se abre (4) y viceversa.
        Consume 1 punto de acción.

        Parámetros:
        - pos: Tupla (x, y) de la posición de la puerta.
        """
        if self.model.matriz_pared[pos[0]][pos[1]] == 5:
            self.model.matriz_pared[pos[0]][pos[1]] = 4
        elif self.model.matriz_pared[pos[0]][pos[1]] == 4:
            self.model.matriz_pared[pos[0]][pos[1]] = 5

        self.action_points -= 1


    def chop_wall(self, pos):
        """
        Rompe una pared en una posición específica.
        Si la pared está en su estado sólido (3), se debilita (a 2 o 1).
        Consume 2 puntos de acción.

        Parámetros:
        - pos: Tupla (x, y) de la posición de la pared.
        """
        if self.model.matriz_pared[pos[0]][pos[1]] == 3:
            self.model.matriz_pared[pos[0]][pos[1]] = 2
        elif self.model.matriz_pared[pos[0]][pos[1]] == 2:
            self.model.matriz_pared[pos[0]][pos[1]] = 1

        self.action_points -= 2


    def apag_fire(self, pos):
        """
        Apaga el fuego en una posición específica.
        Consume 1 punto de acción.

        Parámetros:
        - pos: Tupla (x, y) de la posición donde está el fuego.
        """
        if self.model.matriz_fuego[pos[0]][pos[1]] > 0:
            self.model.matriz_fuego[pos[0]][pos[1]] -= 1
            self.action_points -= 1

    def reveal_POI(self):
        """
        Revela un Punto de Interés (POI) en la posición actual.
        Si el POI es una víctima, el bombero comienza a cargarla.
        Si es una falsa alarma, se elimina del tablero.
        """
        for i in range(len(self.model.game_POI)):
            if self.model.game_POI[i][0] == self.pos[0] \
            and self.model.game_POI[i][1] == self.pos[1]:
                if self.model.game_POI[i][2]:
                    self.model.victims.append([self.pos[0], self.pos[1]])
                    self.model.matriz_pared[self.pos[0]][self.pos[1]] = 8
                else:
                    self.model.matriz_pared[self.pos[0]][self.pos[1]] = 0
                self.model.game_POI.pop(i)
                break

paredes = [
    [[1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 1], [1, 1, 0, 0], [1, 0, 0, 1], [1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 1]],
    [[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1]],
    [[0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 1], [1, 1, 0, 0], [1, 0, 0, 1]],
    [[0, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 0, 1, 1]],
    [[1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 1], [1, 1, 0, 0], [1, 0, 0, 1], [1, 1, 0, 1]],
    [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 1, 1, 0], [0, 0, 1, 1], [0, 1, 1, 1]]
]

puertas = [
    [1, 3, 1, 4],
    [2, 5, 2, 6],
    [2, 8, 3, 8],
    [3, 2, 3, 3],
    [4, 4, 5, 4],
    [4, 6, 4, 7],
    [6, 5, 6, 6],
    [6, 7, 6, 8]
]

entradas = [
    [1, 6],
    [3, 1],
    [4, 8],
    [6, 3]
]

fuegos = [
    [2, 2],
    [2, 3],
    [3, 2],
    [3, 3],
    [3, 4],
    [3, 5],
    [4, 4],
    [5, 6],
    [5, 7],
    [6, 6]
]

POIs = [
    [2,4,True],
    [5,1,False],
    [5,8,True],
]


num_agents = 6
largo = 6
ancho = 8

start_time = time.time()

model = Building(largo, ancho, num_agents, paredes, puertas, entradas, fuegos, POIs)

for i in range(400):
    model.step()



print('Tiempo de ejecución:',
      str(datetime.timedelta(seconds=(time.time() - start_time))))

all_grid = model.datacollector.get_model_vars_dataframe()
data = {}
for i in range(len(all_grid)):
    data[i] = all_grid.iloc[i][0]
all_grid

fig, axs = plt.subplots(figsize=(5, 5))
axs.set_xticks([])
axs.set_yticks([])
patch = plt.imshow(all_grid.iloc[0][0], cmap=plt.cm.Paired)

def animate(i):
    patch.set_data(all_grid.iloc[i][0])

anim = animation.FuncAnimation(fig, animate, frames=len(all_grid))

anim